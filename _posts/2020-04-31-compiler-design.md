---
layout: post
title: Design a Compiler
description : compiler, design, system dev
---

#### Design a Compiler

##### What is a compiler ?
* A Compiler is a software program which translates a program written in a **source language** to equivalent program in the  **target language**.
* **Source language** is generally high level languages like C, C++, Java etc. It is designed and optimized for humans (the syntax is similar to our notion of languages such as english) and is readable and maintenable. It is easier to write, review and in general platform independent.
* **The target language**  is generally machine language or an intermediate language. It is generlly binary(0s and 1s) and the not 
for human to read or write. it is highly optimized to be understood  and executed by the processor.


##### Goals of the Compiler
* **Corretness** - A compiler's most important goal is correctness . All valid programs must compile correctly. What the programmer wanted to achieve in the high level language should reflect in the generated machine code exactly with nothing lost in translation. 

* **Performance** - The code generated by the compiler should be performant.

* **Fast Compile Time** - The compiler should be fast enough to support modern face paced development cycles. Also, the compile time should be proportional to the high level code size.

* **Machine Code Size** - The compile should generate smaller sized binaries.

##### Abstract Design
The compile process comprises of many steps which can be abstracted under two main stages- the front end and the back end.
* The "front end" translates the source language or the high level program into an intermediate representation. 

* The second stage is the "back end", which works with the internal representation to produce code in the output language which is a low level code. 

![Two Stage Compiler Design](/images/two_stage.png "Two Stage Compiler Design")

##### Breaking a complex process in to small steps

* Compiler design is a complex task. We need to break it down to phases and need to go step by step, with each step doing a particular task and passing out its output for the next step in the form of another program representation. 

* The steps can be parse tree generation, high level intermediate code generation, low level intermediate code generation, and then the machine language conversion. As the translation proceeds the representation becomes more and more machine specific, increasingly dealing with registers, memory locations etc.

. Representations become more machine specific and less language specific as the translation proceeds.



 
